<?php

/**
 * Быстрая сортировка (на месте)
 * 
 * Время работы. O(N log N) ожидаемая, O(n^2) в худшем случае.
 * 
 * Область использования. Крупные массивы без большого количества дубликатов,
 * паралельная сортировка.
 * 
 * @param int[] &$values
 * @param int $start
 * @param int $end
 * 
 * @return void
 */
function quickSort(array &$values, int $start, int $end): void {
    // Если в массиве не более одного элемента, значит, он отсортирован.
    if ($start >= $end) {
        return;
    }

    // Используем первы элемент как разделяющий.
    $divider = $values[$start];

    // Перемещаем те элементы которые меньше разделяющего,
    // в начало массива, а те, которые больше или равны ему, - в конец.
    $lowest = $start;
    $highest = $end;

    while (true) {
        // Просматриваем массив с конца от $highest, чтобы найти
        // последний элемент, значение которого меньше разделяющего.
        // Перемещаем найденный элемент в "дырку".
        // Теперь "дырка" возникает на его месте.
        while ($values[$highest] >= $divider) {
            $highest--;

            if ($highest <= $lowest) {
                break;
            }
        }

        if ($highest <= $lowest) {
            // Левая и правая части массива сходятся посередине.
            // Значит, мы закончили. Помещаем сюда разделяющий элемент 
            // и выходим из внешнего цикла.
            $values[$lowest] = $divider;
            break;
        }

        // Перемещаем найденное значение в нижнюю половину.
        $values[$lowest] = $values[$highest];

        // Пересматриваем массив с начала от $lowest в поисках первого
        // элемента, значение которого больше или равно разделяющему.
        // Перемещаем найденый элемент в "дырку".
        // Теперь дырка возникает на его месте.
        $lowest++;
        while ($values[$lowest] < $divider) {
            $lowest++;
            
            if ($lowest >= $highest) {
                break;
            }
        }

        if ($lowest >= $highest) {
            // Левая и правая части массива сходятся посередине,
            // значит, мы закончили. Помещаем сюда разделяющий
            // элемент и выходим из внешнего цикла.
            $lowest = $highest;
            $values[$highest] = $divider;
            break;
        }

        // Перемещаем найденное значение в верхнюю половину.
        $values[$highest] = $values[$lowest];
    }

    // Рекурсивно сортируем две части.
    QuickSort($values, $start, $lowest - 1);
    QuickSort($values, $lowest +1, $end);
}
